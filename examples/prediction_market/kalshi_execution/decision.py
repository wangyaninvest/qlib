# Copyright (c) Prediction Market Bot Example
# Decision Layer - Extends Qlib's decision.py for prediction markets

from __future__ import annotations

from dataclasses import dataclass, field
from enum import IntEnum
from typing import TYPE_CHECKING, ClassVar, List, Optional, Tuple, Union
from abc import abstractmethod

import pandas as pd
import numpy as np

if TYPE_CHECKING:
    from .strategy import EdgeBasedStrategy


class ContractOrderDir(IntEnum):
    """Order direction for binary contracts"""
    SELL_YES = 0   # Sell YES contracts (equivalent to buying NO)
    BUY_YES = 1    # Buy YES contracts
    SELL_NO = 2    # Sell NO contracts (equivalent to buying YES)  
    BUY_NO = 3     # Buy NO contracts


@dataclass
class ContractOrder:
    """
    Order for prediction market contracts.
    
    Extends Qlib's Order concept for binary event contracts.
    
    Attributes
    ----------
    market_id : str
        Kalshi market identifier (e.g., "KXBTC-24JAN01-T50000")
    contract_type : str
        "YES" or "NO"
    direction : ContractOrderDir
        Buy or sell direction
    quantity : int
        Number of contracts (each contract pays $1 if correct)
    limit_price : float
        Limit price in [0.01, 0.99]
    start_time : pd.Timestamp
        Order submission time
    end_time : pd.Timestamp
        Order expiration time (GTC, GTD, etc.)
    """
    
    # Core order fields
    market_id: str
    contract_type: str  # "YES" or "NO"
    direction: ContractOrderDir
    quantity: int
    limit_price: float
    
    # Time bounds
    start_time: pd.Timestamp
    end_time: pd.Timestamp
    
    # Execution results (filled by exchange)
    filled_quantity: int = 0
    avg_fill_price: float = 0.0
    status: str = "pending"  # pending, partial, filled, cancelled, expired
    order_id: Optional[str] = None
    
    # Class constants for backward compat
    BUY_YES: ClassVar[ContractOrderDir] = ContractOrderDir.BUY_YES
    SELL_YES: ClassVar[ContractOrderDir] = ContractOrderDir.SELL_YES
    BUY_NO: ClassVar[ContractOrderDir] = ContractOrderDir.BUY_NO
    SELL_NO: ClassVar[ContractOrderDir] = ContractOrderDir.SELL_NO
    
    def __post_init__(self):
        """Validate order parameters"""
        if self.limit_price < 0.01 or self.limit_price > 0.99:
            raise ValueError(f"Limit price must be in [0.01, 0.99], got {self.limit_price}")
        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive, got {self.quantity}")
        if self.contract_type not in ("YES", "NO"):
            raise ValueError(f"Contract type must be 'YES' or 'NO', got {self.contract_type}")
    
    @property
    def is_buy(self) -> bool:
        """Check if this is a buy order"""
        return self.direction in (ContractOrderDir.BUY_YES, ContractOrderDir.BUY_NO)
    
    @property
    def max_cost(self) -> float:
        """Maximum cost if fully filled (for buying)"""
        if self.is_buy:
            return self.quantity * self.limit_price
        else:
            # Selling: max loss is (1 - limit_price) if contract settles against us
            return self.quantity * (1 - self.limit_price)
    
    @property
    def max_profit(self) -> float:
        """Maximum profit if fully filled and contract settles in our favor"""
        if self.is_buy:
            return self.quantity * (1 - self.limit_price)
        else:
            return self.quantity * self.limit_price
    
    @property
    def key(self) -> tuple:
        """Unique identifier for this order"""
        return (self.market_id, self.contract_type, self.direction, self.start_time)
    
    def to_dict(self) -> dict:
        """Convert to dictionary for API submission"""
        return {
            "ticker": self.market_id,
            "side": "yes" if self.contract_type == "YES" else "no",
            "action": "buy" if self.is_buy else "sell",
            "count": self.quantity,
            "type": "limit",
            "yes_price" if self.contract_type == "YES" else "no_price": int(self.limit_price * 100),
            "expiration_ts": int(self.end_time.timestamp()) if self.end_time else None,
        }


@dataclass
class PredictionMarketDecision:
    """
    Trade decision for prediction markets.
    
    Analogous to Qlib's BaseTradeDecision but adapted for binary contracts.
    Contains a list of contract orders generated by a strategy.
    """
    
    orders: List[ContractOrder] = field(default_factory=list)
    strategy: Optional["EdgeBasedStrategy"] = None
    created_time: pd.Timestamp = field(default_factory=pd.Timestamp.now)
    
    # Decision metadata
    model_confidence: Optional[float] = None
    edge_threshold_used: Optional[float] = None
    
    def __len__(self) -> int:
        return len(self.orders)
    
    def get_order_list(self) -> List[ContractOrder]:
        """Get all orders in this decision"""
        return self.orders
    
    def add_order(self, order: ContractOrder) -> None:
        """Add an order to the decision"""
        self.orders.append(order)
    
    def get_buy_orders(self) -> List[ContractOrder]:
        """Filter to only buy orders"""
        return [o for o in self.orders if o.is_buy]
    
    def get_sell_orders(self) -> List[ContractOrder]:
        """Filter to only sell orders"""
        return [o for o in self.orders if not o.is_buy]
    
    def total_capital_required(self) -> float:
        """Calculate total capital needed for all buy orders"""
        return sum(o.max_cost for o in self.get_buy_orders())
    
    def total_margin_required(self) -> float:
        """Calculate margin needed for sell orders"""
        return sum(o.max_cost for o in self.get_sell_orders())
    
    def to_dataframe(self) -> pd.DataFrame:
        """Convert decision to DataFrame for analysis"""
        if not self.orders:
            return pd.DataFrame()
        
        records = []
        for order in self.orders:
            records.append({
                "market_id": order.market_id,
                "contract_type": order.contract_type,
                "direction": order.direction.name,
                "quantity": order.quantity,
                "limit_price": order.limit_price,
                "max_cost": order.max_cost,
                "max_profit": order.max_profit,
                "status": order.status,
            })
        return pd.DataFrame(records)


class DecisionGenerator:
    """
    Utility class to generate trade decisions from model signals.
    Similar to Qlib's order_generator.py but for prediction markets.
    """
    
    def __init__(
        self,
        edge_threshold: float = 0.05,
        kelly_fraction: float = 0.25,
        max_position_per_market: int = 100,
        max_order_value: float = 500.0,
    ):
        """
        Parameters
        ----------
        edge_threshold : float
            Minimum edge (model_prob - market_price) to generate signal
        kelly_fraction : float
            Fraction of Kelly criterion to use (for risk reduction)
        max_position_per_market : int
            Maximum contracts per market
        max_order_value : float
            Maximum dollar value per order
        """
        self.edge_threshold = edge_threshold
        self.kelly_fraction = kelly_fraction
        self.max_position_per_market = max_position_per_market
        self.max_order_value = max_order_value
    
    def generate_decision(
        self,
        signals: pd.DataFrame,
        current_positions: dict,
        available_capital: float,
        current_time: pd.Timestamp,
    ) -> PredictionMarketDecision:
        """
        Generate trade decision from model signals.
        
        Parameters
        ----------
        signals : pd.DataFrame
            DataFrame with columns: market_id, model_prob, market_price, expiration
        current_positions : dict
            Current positions by market_id: {market_id: {"yes": qty, "no": qty}}
        available_capital : float
            Available cash for new positions
        current_time : pd.Timestamp
            Current timestamp
            
        Returns
        -------
        PredictionMarketDecision
            The generated trade decision
        """
        decision = PredictionMarketDecision(created_time=current_time)
        
        for _, row in signals.iterrows():
            market_id = row["market_id"]
            model_prob = row["model_prob"]
            market_price = row["market_price"]  # YES price
            expiration = row.get("expiration", current_time + pd.Timedelta(days=1))
            
            # Calculate edge
            edge_yes = model_prob - market_price
            edge_no = (1 - model_prob) - (1 - market_price)  # = market_price - model_prob
            
            # Check for YES opportunity
            if edge_yes > self.edge_threshold:
                order = self._create_order(
                    market_id=market_id,
                    contract_type="YES",
                    direction=ContractOrderDir.BUY_YES,
                    edge=edge_yes,
                    price=market_price,
                    current_position=current_positions.get(market_id, {}).get("yes", 0),
                    available_capital=available_capital,
                    current_time=current_time,
                    expiration=expiration,
                )
                if order:
                    decision.add_order(order)
                    available_capital -= order.max_cost
            
            # Check for NO opportunity (negative edge on YES)
            elif edge_no > self.edge_threshold:
                order = self._create_order(
                    market_id=market_id,
                    contract_type="NO",
                    direction=ContractOrderDir.BUY_NO,
                    edge=edge_no,
                    price=(1 - market_price),
                    current_position=current_positions.get(market_id, {}).get("no", 0),
                    available_capital=available_capital,
                    current_time=current_time,
                    expiration=expiration,
                )
                if order:
                    decision.add_order(order)
                    available_capital -= order.max_cost
        
        return decision
    
    def _create_order(
        self,
        market_id: str,
        contract_type: str,
        direction: ContractOrderDir,
        edge: float,
        price: float,
        current_position: int,
        available_capital: float,
        current_time: pd.Timestamp,
        expiration: pd.Timestamp,
    ) -> Optional[ContractOrder]:
        """Create a single order using Kelly criterion"""
        
        # Kelly sizing: f* = (p * b - q) / b where b = odds, p = prob, q = 1-p
        # For binary contracts: b = (1-price)/price, p = price + edge
        prob = price + edge
        odds = (1 - price) / price if price > 0 else 0
        
        if odds <= 0:
            return None
        
        kelly_full = (prob * odds - (1 - prob)) / odds
        kelly_fraction_size = kelly_full * self.kelly_fraction
        
        # Convert to dollar amount
        position_value = available_capital * max(0, kelly_fraction_size)
        position_value = min(position_value, self.max_order_value)
        
        # Convert to contract quantity
        quantity = int(position_value / price)
        
        # Apply position limits
        remaining_capacity = self.max_position_per_market - current_position
        quantity = min(quantity, remaining_capacity)
        
        if quantity <= 0:
            return None
        
        return ContractOrder(
            market_id=market_id,
            contract_type=contract_type,
            direction=direction,
            quantity=quantity,
            limit_price=price,
            start_time=current_time,
            end_time=expiration,
        )
